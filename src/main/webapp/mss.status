
// rdf prefixes:
String prefix = "prefix cts: <http://www.homermultitext.org/cts/rdf/>\nprefix cite: <http://www.homermultitext.org/cite/rdf/>\nprefix hmt: <http://www.homermultitext.org/hmt/rdf/>\nprefix citedata: <http://www.homermultitext.org/hmt/citedata/>\nprefix dcterms: <http://purl.org/dc/terms/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix  xsd: <http://www.w3.org/2001/XMLSchema#>\nprefix olo: <http://purl.org/ontology/olo/core#>"


String getSparqlReply(String acceptType, String query) {
  String replyString
  def encodedQuery = URLEncoder.encode(query)
  def q = "@sparqls@query?query=${encodedQuery}"
  if (acceptType == "application/json") {
    q +="&output=json"
  }

  URL queryUrl = new URL(q)
  return queryUrl.getText("UTF-8")

}

String iliadLineCountQuery = """
select ?ms ?label (count(?ln) AS ?num)  WHERE {
?ln <http://www.homermultitext.org/cite/rdf/appearsOn> ?folio .
?folio <http://www.homermultitext.org/cite/rdf/belongsTo> ?ms .
?ms <http://www.w3.org/2000/01/rdf-schema#label> ?label .
FILTER (regex(str(?ln),"urn:cts:greekLit:tlg0012.tlg001.*" ) ) .
}
GROUP BY ?ms ?label
"""

String iliadFolioCountQuery = """
select ?ms ?label (count(DISTINCT ?folio) AS ?num)  WHERE {
?ln <http://www.homermultitext.org/cite/rdf/appearsOn> ?folio .
?folio <http://www.homermultitext.org/cite/rdf/belongsTo> ?ms .
?ms <http://www.w3.org/2000/01/rdf-schema#label> ?label .
FILTER (regex(str(?ln),"urn:cts:greekLit:tlg0012.tlg001.*" ) ) .
}
GROUP BY ?ms ?label
"""



String browsableQuery = """
SELECT ?century ?pgmodel ?label (count(?folio) AS ?cnt )  WHERE {
   ?codex <http://www.homermultitext.org/hmt/citedata/codices_pageModel>  ?pgmodel .
   ?codex <http://www.homermultitext.org/hmt/citedata/codices_century>  ?century  .
   ?codex <http://www.w3.org/2000/01/rdf-schema#label> ?label .
   ?pgmodel <http://www.homermultitext.org/cite/rdf/possesses>  ?folio .
   ?folio  <http://purl.org/ontology/olo/core#item>  ?seq .

}
GROUP BY  ?century ?pgmodel ?label
ORDER BY ?century ?pgmodel
"""

html.html {
  head {
    title("@projectlabel@: status of manuscript documentation")
    link(type : "text/css", rel : "stylesheet", href : "css/browsers.css", title : "CSS stylesheet")
    link(type : "text/css", rel : "stylesheet", href : "@coreCss@", title : "CSS stylesheet")
    script(type: "text/javascript", src : "js/jquery.min.js", "  ")
    script(type: "text/javascript", src : "@citekit@", "  ")
  }

  body {

    header(role: "banner") {
      mkp.yield ("Digital services from the Homer Multitext project")
      nav(role: "navigation") {
	ul {
	  li {
	    mkp.yield("HMT: ")
	    a(href: "http://www.homermultitext.org", "home")
	  }
	  li {
	    mkp.yield("HMT Digital: ")
	    a(href: "home", "home")
	  }

	  li {
	    a(href: "mss", "browse MSS")
	  }
	  li {
	    a(href: "scholia", "scholia")
	  }
	}
      }
    }
    article {

      h2 ("Summary of status: documenting manuscripts")

      h3 {
	mkp.yield("Pages of facsimile indexed to")
	em("Iliad")
	mkp.yield (" text")
      }
      p {
	mkp.yield "(Lookup page by "
	em("Iliad")
	mkp.yield (" line ")
	a (href: "mss", "here")
	mkp.yield ".)"
      }


      def pagesMap = [:]
      def folioSlurper = new groovy.json.JsonSlurper()
      def indexedPages = folioSlurper.parseText(getSparqlReply("application/json", iliadLineCountQuery))
      indexedPages.results.bindings.each { b ->
	pagesMap[b.ms.value] = b.num.value
	/*
	p {
	  mkp.yield("${b.label?.value}:  ")
	  strong("${b.num?.value} lines")
	  mkp.yield(" indexed.")

	  }*/
      }


      def lnSlurper = new groovy.json.JsonSlurper()
      def indexedLines = lnSlurper.parseText(getSparqlReply("application/json", iliadFolioCountQuery))
      table {
	tr {
	  th("Manuscript")
	  th {
	    em("Iliad")
	    mkp.yield " lines"
	  }
	  th("Pages")
	}
	indexedLines.results.bindings.each { b ->
	tr {
	  td(b.label.value)
	  td(pagesMap[b.ms.value])
	  td(b.num.value)

	}

      }


      }
	/*

	p {
	  mkp.yield("${b.label?.value}:  ")
	  strong("${b.num?.value} lines")
	  mkp.yield(" indexed.")
	  linesMap[b.ms.value] = b.num.value
	}
	}*/


      h3("Pages browsable in facsimile")
      def msSlurper = new groovy.json.JsonSlurper()
      def browsables = msSlurper.parseText(getSparqlReply("application/json", browsableQuery))


      p {
	mkp.yield "(Browse facsimiles "
	a (href: "mss", "here")
	mkp.yield ".)"
      }

      String prevCentury = ""
      browsables.results.bindings.each { b ->
	if (b.century?.value != prevCentury) {
	  prevCentury = b.century?.value
	  h4 {
	    strong("${b.century?.value}th century")
	  }
	}

	p {
	  mkp.yield("${b.label?.value}:  ")
	  strong("${b.cnt?.value} pages")
	  mkp.yield(".")
	}
      }
    }
    footer("@htmlfooter@")
  }
}
