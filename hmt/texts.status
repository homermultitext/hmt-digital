
// rdf prefixes:
String prefix = "prefix cts: <http://www.homermultitext.org/cts/rdf/>\nprefix cite: <http://www.homermultitext.org/cite/rdf/>\nprefix hmt: <http://www.homermultitext.org/hmt/rdf/>\nprefix citedata: <http://www.homermultitext.org/hmt/citedata/>\nprefix dcterms: <http://purl.org/dc/terms/>\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix  xsd: <http://www.w3.org/2001/XMLSchema#>\nprefix olo: <http://purl.org/ontology/olo/core#>"


String getSparqlReply(String acceptType, String query) {
  String replyString
  def encodedQuery = URLEncoder.encode(query)
  def q = "@sparqls@query?query=${encodedQuery}"
  if (acceptType == "application/json") {
    q +="&output=json"
  }

  URL queryUrl = new URL(q)
  return queryUrl.getText("UTF-8")

}




/*Edited texts */
String editions = """
${prefix}
select ?label ?ed where {
    ?ed rdf:type cts:Edition  .
    ?ed rdf:label ?label .
}
"""


String pageStatusQuery = """

prefix cts: <http://www.homermultitext.org/cts/rdf/>
prefix cite: <http://www.homermultitext.org/cite/rdf/>
prefix hmt: <http://www.homermultitext.org/hmt/rdf/>
prefix citedata: <http://www.homermultitext.org/hmt/citedata/>
prefix dcterms: <http://purl.org/dc/terms/>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix  xsd: <http://www.w3.org/2001/XMLSchema#>
prefix olo: <http://purl.org/ontology/olo/core#>

SELECT ?ms ?mslabel ?status ?level ?label  (count(?status) AS ?num)  WHERE {
?status hmt:statusOf ?pg .
?status citedata:edstatus_Meaning ?label .
?status citedata:edstatus_Tier ?level .
?pg cite:belongsTo ?ms .
?ms <http://www.w3.org/1999/02/22-rdf-syntax-ns#label> ?mslabel .

} 
GROUP BY ?ms ?mslabel ?level ?status ?label
ORDER BY ?ms DESC(?level)
"""

String iliadLinesQuery = """
select ?ms ?label (count(?ln) AS ?num)  WHERE {
?ln <http://www.homermultitext.org/cite/rdf/appearsOn> ?folio . 
?ln  <http://www.homermultitext.org/cts/rdf/belongsTo> ?vers .
?vers <http://www.homermultitext.org/cts/rdf/belongsTo>  <urn:cts:greekLit:tlg0012.tlg001> .
?vers <http://www.w3.org/1999/02/22-rdf-syntax-ns#label> ?label .
}
GROUP BY ?ms ?label 
"""


String scholiaByDocQuery = """
select ?ms ?mslabel ?label (count(?ln) AS ?num)  WHERE {
?ln <http://www.homermultitext.org/cite/rdf/appearsOn> ?folio . 
?folio <http://www.homermultitext.org/cite/rdf/belongsTo> ?ms .
?ms <http://www.w3.org/1999/02/22-rdf-syntax-ns#label> ?mslabel .
?ln  <http://www.homermultitext.org/cts/rdf/belongsTo> ?vers .
?vers <http://www.homermultitext.org/cts/rdf/belongsTo>  ?wk .
?wk <http://www.homermultitext.org/cts/rdf/belongsTo> <urn:cts:greekLit:tlg5026> .
?vers <http://www.w3.org/1999/02/22-rdf-syntax-ns#label> ?label .
}
GROUP BY ?label ?ms ?mslabel
ORDER BY ?ms DESC(?num)
"""




html.html {
  head {
    title("@projectlabel@: status of work")
    link(type : "text/css", rel : "stylesheet", href : "css/browsers.css", title : "CSS stylesheet")
    link(type : "text/css", rel : "stylesheet", href : "@coreCss@", title : "CSS stylesheet")
    script(type: "text/javascript", src : "js/jquery.min.js", "  ")
    script(type: "text/javascript", src : "@citekit@", "  ")
  }
  
  body {

    header(role: "banner") {
      mkp.yield ("Digital services from the Homer Multitext project")
      nav(role: "navigation") {
	ul {
	  li {
	    mkp.yield("HMT: ")
	    a(href: "http://www.homermultitext.org", "home")
	  }
	  li {
	    mkp.yield("HMT Digital: ")
	    a(href: "home", "home")
	  }

	  li {
	    a(href: "mss", "browse MSS")
	  }
	  li {
	    a(href: "scholia", "scholia")
	  }
	}
      }
    }
    article {

      h2 ("Summary of status: editing texts")
      h3 { 
	em("Iliad")
      }
      p {
	mkp.yield("Lines of the ")
	em("Iliad")
	mkp.yield (" by manuscript.")
      }
      def ilSlurper = new groovy.json.JsonSlurper()
      def ilLines = ilSlurper.parseText(getSparqlReply("application/json", iliadLinesQuery))
      ilLines.results.bindings.each { b -> 
	p {
	  mkp.yield("${b.label.value}: ")
	  strong("${b.num.value} lines")
	  mkp.yield(" edited.")
	}
      }

      h3("Scholia")

      p ("Number of scholia by document.")
      def scholSlurper = new groovy.json.JsonSlurper()
      def scholia = ilSlurper.parseText(getSparqlReply("application/json", scholiaByDocQuery))

      String prevMs = ""
      Integer msTotal = 0
      scholia.results.bindings.each { b -> 
	if (b.ms.value != prevMs) {
	  if (msTotal != 0) {
	    p {
	      strong("Total: ${msTotal} scholia")
	    }
	  }
	  h4 {
	    strong("${b.mslabel.value}")
	    prevMs = b.ms.value
	    msTotal = 0
	  }
	}
	p {
	  mkp.yield("${b.label.value}: ")
	  strong("${b.num.value} scholia")
	  mkp.yield(" edited.")
	  Integer subtotal = b.num.value as Integer
	  msTotal += subtotal
	}
      }
      p {
	strong("Total: ${msTotal} scholia")
      }


      p {
	mkp.yield "("
	em("add subtotals by book of Iliad, and # words of Greek")
	mkp.yield(")")
      }


      h3("Validation level (by page)")
      def pgSlurper = new groovy.json.JsonSlurper()
      def pgStatusSummary = pgSlurper.parseText(getSparqlReply("application/json", pageStatusQuery))
      
      prevMs = ""
      Integer total = 0
      pgStatusSummary.results.bindings.each { b -> 
	if (b.ms.value != prevMs) {
	  if (total > 0) {
	    p {
	      strong("Total: ${total} pages.")
	      total = 0
	    }
	  }
	  h4 {
	    strong(b.mslabel?.value)
	  }
	  prevMs = b.ms.value
	}
	Integer subtotal = b.num.value as Integer
	total += subtotal
	if (b.num.value == "1") {
	  p {
	    mkp.yield ("${b.label.value}: ")
	    strong("1 page")
	    mkp.yield(".")
	  }
	} else {
	  p {
	    mkp.yield ("${b.label.value}: ")
	    strong("${b.num.value} pages")
	    mkpyield(".")
	  }
	}
      }
      p {
	strong("Total: ${total} pages.")
      }

    }
    footer("@htmlfooter@")
  }
}



